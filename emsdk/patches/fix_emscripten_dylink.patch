diff --git a/emsdk/upstream/emscripten/src/library.js b/emsdk/upstream/emscripten/src/library.js
index d5e9d62..ea4cf27 100644
--- a/emsdk/upstream/emscripten/src/library.js
+++ b/emsdk/upstream/emscripten/src/library.js
@@ -3747,6 +3747,15 @@ LibraryManager.library = {
 #endif
 #if ASSERTIONS
     assert(wasmTable.get(ptr), 'missing table entry in dynCall: ' + ptr);
+#endif
+#if EMULATE_FUNCTION_POINTER_CASTS
+    if( ptr in dyncallInvokeMap)
+    {
+        // in fpcast mode, we use a separate table or else we'll attempt
+        // to call the fpcast emulated version which is not what the linker 
+        // expects for a linked dynamic call
+        ptr=dyncallInvokeMap[ptr];
+    }
 #endif
     return wasmTable.get(ptr).apply(null, args)
 #endif
diff --git a/emsdk/upstream/emscripten/src/library_dylink.js b/emsdk/upstream/emscripten/src/library_dylink.js
index 876492b..3839ea2 100644
--- a/emsdk/upstream/emscripten/src/library_dylink.js
+++ b/emsdk/upstream/emscripten/src/library_dylink.js
@@ -3,7 +3,9 @@
 //
 // ==========================================================================
 
+
 var LibraryDylink = {
+
 #if RELOCATABLE
   $asmjsMangle: function(x) {
     var unmangledSymbols = {{{ buildStringArray(WASM_SYSTEM_EXPORTS) }}};
@@ -57,6 +59,7 @@ var LibraryDylink = {
         err("new GOT entry: " + symName);
 #endif
       }
+
       return GOT[symName]
     }
   },
@@ -94,29 +97,59 @@ var LibraryDylink = {
         replace = true;
       }
 #endif
-
-      if (!GOT[symName]) {
-        GOT[symName] = new WebAssembly.Global({value: 'i32', mutable: true});
+      baseName=symName;
+#if EMULATE_FUNCTION_POINTER_CASTS==1
+      const FPCAST_PREFIX="byn$fpcast-emu$";
+      const FPCAST_DYNCALL_PREFIX="$no-fpcast-emu$";
+      if(symName.startsWith(FPCAST_PREFIX))
+      {
+          baseName=symName.substr(FPCAST_PREFIX.length)
+      }else
+      {
+         if(FPCAST_PREFIX+symName in exports)
+         {
+             baseName=FPCAST_DYNCALL_PREFIX+symName;
+         }
       }
-      if (replace || GOT[symName].value == 0) {
+#endif
+      if (!GOT[baseName]) {
+        GOT[baseName] = new WebAssembly.Global({value: 'i32', mutable: true});
+      }
+      if (replace || GOT[baseName].value == 0) {
         if (typeof value === 'function') {
-          GOT[symName].value = addFunctionWasm(value);
+          GOT[baseName].value = addFunctionWasm(value);
 #if DYLINK_DEBUG
-          err("updateGOT FUNC: " + symName + ' : ' + GOT[symName].value);
+          err("updateGOT FUNC: " + symName + ' : ' + GOT[baseName].value);
 #endif
         } else if (typeof value === 'number') {
-          GOT[symName].value = value;
+          GOT[baseName].value = value;
         } else {
           err("unhandled export type for `" + symName + "`: " + (typeof value));
         }
 #if DYLINK_DEBUG
-        err("updateGOT: " + symName + ' : ' + GOT[symName].value);
+        err("updateGOT: " + baseName + "("+ symName + ")" + ' : ' + GOT[symName].value);
 #endif
       }
 #if DYLINK_DEBUG
-      else if (GOT[symName].value != value) {
-        err("updateGOT: EXISTING SYMBOL: " + symName + ' : ' + GOT[symName].value + " " + value);
+      else if (GOT[baseName].value != value) {
+        err("updateGOT: EXISTING SYMBOL: " + symName + ' : ' + GOT[baseName].value + " " + value);
       }
+#endif
+#if EMULATE_FUNCTION_POINTER_CASTS==1
+        // update map for dynamic calls so they can bypass fp casts
+        if(symName.startsWith(FPCAST_PREFIX))
+        {
+            if(GOT[FPCAST_DYNCALL_PREFIX+baseName] && GOT[FPCAST_DYNCALL_PREFIX+baseName].value!=0)
+            {
+                dyncallInvokeMap[GOT[baseName].value]=GOT[FPCAST_DYNCALL_PREFIX+baseName].value;
+            }
+        }else if(baseName.startsWith(FPCAST_DYNCALL_PREFIX))
+        {
+            if(GOT[symName] && GOT[symName].value!=0)
+            {
+                dyncallInvokeMap[GOT[symName].value]=GOT[baseName].value;
+            }
+        }
 #endif
     }
 #if DYLINK_DEBUG
@@ -754,6 +787,10 @@ var LibraryDylink = {
     // http://pubs.opengroup.org/onlinepubs/009695399/functions/dlsym.html
     symbol = UTF8ToString(symbol);
     var result;
+#if EMULATE_FUNCTION_POINTER_CASTS==1
+      // look for fpcast-emu version as this is deffo going to be a function pointer that we return
+      symbol="byn$fpcast-emu$"+symbol
+#endif
 
     if (handle == {{{ cDefine('RTLD_DEFAULT') }}}) {
       result = resolveGlobalSymbol(symbol, true);
diff --git a/emsdk/upstream/emscripten/src/runtime_init_table.js b/emsdk/upstream/emscripten/src/runtime_init_table.js
index c8af59d..7084ff7 100644
--- a/emsdk/upstream/emscripten/src/runtime_init_table.js
+++ b/emsdk/upstream/emscripten/src/runtime_init_table.js
@@ -13,3 +13,17 @@ var wasmTable = new WebAssembly.Table({
 // the exports are available.
 var wasmTable;
 #endif
+#if EMULATE_FUNCTION_POINTER_CASTS==1
+    // when we call dynamic link functions through the relocation
+    // invoke xxx methods, we aren't doing a function pointer
+    // call, so we don't mess with the function prototype.
+    // however, we do need to make the function table
+    // point to the emulated bny$fpcast-emu$ function pointer calls or else you
+    // can't take function pointers in wasm code.
+    // this means we need a different table for javascript dyncall invokes
+    // as given these are pre-linked and don't use function pointer casts, they
+    // will use the non-emulated version with the normal arguments.
+    // nb. this doesn't have to be a proper wasm table because it is
+    // only ever called from javascript
+    var dyncallInvokeMap={};
+#endif
